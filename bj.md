# 脏读, 幻读, 不可重复?

脏读, 读到了假数据, 读脏

> 初始化数据, insert into user(name, money) values ('张三', 0);

| session1                                                     | session2                                        |
| ------------------------------------------------------------ | ----------------------------------------------- |
| begin;                                                       | begin;                                          |
|                                                              | Update interview.user set money=200 where id=1; |
| select * from user where id=1; -- 拿着money去做了一些事情(业务流程) |                                                 |
| commit;                                                      |                                                 |
|                                                              | rollback; -- 遇到错误,回滚了                    |



幻读, 有或无的问题, 第一次读没有这条数据, 第二读的时候有了这条数据

| session1                                                  | session2                                            |
| --------------------------------------------------------- | --------------------------------------------------- |
| begin;                                                    | Begin;                                              |
| Select * from interview.user where money=123; -- 没有数据 |                                                     |
|                                                           | insert into user(name, money) values ('张四', 123); |
|                                                           | commit;                                             |
| Select * from interview.user where money=123; -- 有数据   |                                                     |
| commit;                                                   |                                                     |

我是不是说产生了幻觉?幻读



不可重复读, 数目上面, 两次读出来的个数不一致

| session1                                 | session2                             |
| ---------------------------------------- | ------------------------------------ |
| begin;                                   | Begin;                               |
| Select * from interview.user where id=1; |                                      |
|                                          | Update interview.user set money=999; |
|                                          | commit;                              |
| Select * from interview.user where id=1; |                                      |
| commit;                                  |                                      |

什么情况下会有这些问题?

并发 + 事务(事务隔离级别)+Innodb

隔离级别???是什么?

有四个隔离级别(从上往下越来越高)

1. 未提交读 read uncommited
2. 提交读 read commited
3. 可重复读 repeatable read , 默认
4. 串行化 serializable

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 未提交读 | 可能   | 可能       | 可能   |
| 提交读   | 不可能 | 可能       | 可能   |
| 可重复读 | 不可能 | 不可能     | 可能   |
| 串行化   | 不可能 | 不可能     | 不可能 |

MySQL为了解决并发问题, 对事物进行了隔离处理.

# 隔离处理是怎么实现的?

用锁来实现的

都有什么锁?作用是什么?

我怎么看这个锁?

还有,阻塞是怎么实现的?

PHP真正运行的时候,和模拟的情况是不是完全一致?

要真正用PHP去处理并发问题?

PHP怎么模拟并发?

PHP要模拟什么样的并发业务?会产生什么问题?

事务隔离级别有四个, 那每个级别下会产生的问题, 都是怎么样产生的?

提高了隔离级别,为什么就能避免这些问题?原理是什么?

唯一索引的问题, MySQL加不加唯一索引, 只是对搜索数据速度有影响

比如, 姓名(unique),如果不加唯一索引,当事务并发的时候, 我用PHP去判断的是否唯一,就没有意义

```php
<?php
  // 比如说要插入名称叫  "张三" 的用户
  $name = "张三";
 //从数据库查找名称是 "张三" 用户
$ret = "select * from user where name=$name";
if($ret){
  $this->error("已存在");
}else{
  // 插入张三
  $sql = " insert into "
}

// 这个数据的唯一性, 就被破坏了
```

嗯, 今天说一下MySQL的锁的类型, MySQL的锁可以按照三种模式来划分

第一种, 就是 按照算法来划分: 记录锁, 间隙锁, 临键锁

这个记录锁, 就是指锁定了某条记录, 间隙锁呢, 就是锁定了一个开区间(>2并且<6 的区间,就是不带等于的区间), 这个就是间隙锁,  临键锁,就相当于是`记录锁`和`间隙锁`的组合,效果是一个闭区间,比如:[2,6)

第二种划分是, 按照共享策略来划分: 分为 共享锁(S), 排它锁(X), 还有,意向共享锁(IS), 意向排它锁(IX)

然后, 这个意向是什么意思呢? 他的英文是 intention, 就是代表, 我要上...锁了, 就是通知一下MySQL, 我要上排它锁, 或者共享锁了, 

然后这个共享呢,英文share, 排它的英文是exclusive, 这就是排他的意思,所以说,这个共享锁的英文就是S

第三种,然后然后然后, 就是按这个加锁策略来分: 悲观锁, 乐观锁, 悲观锁就是, 先加锁,再操作, 乐观锁呢, 就是先操作, 再看有没有冲突

> 意向锁,有什么用呢? 
>
> 意向锁, 是加在表上的, 要加锁之前, 就必须先获取表的意向锁, 比如说, 要加排它锁(行锁), 那就得先获取表的意向排它锁,然后才能加行级的排它锁, 用处就是判断当前表是否 `没有锁` , 如果表上面,没有意向排它锁, 那么这个表,肯定就没有排它锁(共享锁), 如果要加的锁和(排它锁)冲突, 那就可放心的加了, 不然的话, 要遍历每个记录看有没有冲突的锁

者三种策略来分, 就产生了很多种锁的类型, 如下

1. 排它锁(行数据), 因为是在写,修改, 删除的时候, 加的锁, 所以就就近去了第一个字,叫`写锁`
2. 共享锁(行数据), 因为是在读的时候, 加的锁, 所以,又叫`行锁`
3. 间隙排它锁(好多个行), 间隙, 就是在没有的记录上加锁, 现有2,4, 然后一个事务查询<4, 另一个事务插入3,那就会被阻塞, 阻塞的这个锁, 就是间隙锁, 他是锁定了一个范围, 不是锁定的具体行, 插个3.5,照样锁,防止幻读产生
   1. 因为MySQL的隔离级别有四个, ru(read uncommitted), rc(read committed), rr(repeatable read), sr(serialize read), ru和rc模式下, 没有间隙锁, 所以, 你在ru和rc模式下显示的加排它锁(select...for update)或者共享锁(select... in share mode), 也不能解决幻读的问题
4. 间隙共享锁,S_GAP
5. 意向排它锁, 加在表上的, 带意向两个字的都是加在表上的
6. 意向共享锁IS
7. 自动增加锁,AUTO_INC LOCK 有自增列的时候(auto_increment),比如id, 防止并发的时候, 出现两个相同的id, MySQL实现了这个锁的机制, 当然了, 这个锁还有很大的文章, 和主从复制还有关系, 就是还有很多的未知需要探索, 我们以后在一起学习
8. 意向排他间隙锁, IX_GAP
9. 意向共享锁间隙锁IS_GAP
10. 插入意向锁, IIX, 只用于并发插入操作
11. 预测锁???????????,这个还是有待学习

总结:

| 中文 | 英文      | 简写 |
| ---- | --------- | ---- |
| 意向 | intention | I    |
| 排他 | exclusive | X    |
| 间隙 | gap       | GAP  |
| 共享 | share     | S    |

今天也是继续挖坑的一天, 因为我也是遇到了更多的新问题,再见👋🏻